---
layout: post
id: 479
alias: use-jdk-builtin-jvisualvm-to-check-multithread-competition
tags: Java
date: 2011-10-23 12:55:01
title: 利用jdk自带的强悍工具jvisualvm检测多线程的竞争
---

我有一个程序，里面有大量的synchronized关键字。我怀疑它们导致的多线程竞争影响了程序的性能。但不知道如何去检测，总不能只凭自己的猜测就去修改它们，万一改到最后发现不是它们的问题，岂不浪费了。

用什么工具来测试呢？我以前用过jprofiler，那个虽然功能强大，但不是免费的。于是我在万能的stackoverflow上提了个问题，聆听神人的教诲。

[http://stackoverflow.com/questions/7858730/how-to-know-how-much-time-cost-by-synchronized-code-in-java](http://stackoverflow.com/questions/7858730/how-to-know-how-much-time-cost-by-synchronized-code-in-java)

果然，很快有人提供了一个很强大的免费工具：JDK6自带的jvisualvm。

这个东西我以前听过说，但一直没有用过。看到它提供的截图中可以看到各线程的运行状态，所以准备试一下。这里记录一下使用过程。

**1。启动**

在命令行输入jvisualvm。如果jdk安装正确的话(6.x以上版本），就会看到如下的一个窗口：

![](/user_images/479-0.png)

看起来相当简洁，不像是很强大的样子。

 <span id="more-479"></span>
<p>**2。运行一个Java程序IncTestN，jvisualvm会自动找到它**

![](/user_images/479-1.png)

**3.右键点击它，"打开"**

![](/user_images/479-2.png)

可以看到它有很多标签页，可以让我们监测程序的各种数据。默认没有这么多，我其实安装了一些jvisualvm的插件。

**4。查看jvm参数及系统属性**

![](/user_images/479-3.png)

**5。查看cpu、内存、类、线程的统计数据**

![](/user_images/479-4.png)

注意，右边第一个还可以查看PermGen。对于scala程序，因为它产生了大量的类定义，所以PermGen有可能会不足，可通过该选项查看PermGen，适当调整：

![](/user_images/479-5.png)

可以看到，对于本程序来说，PermGen还是比较充分的，无须调整。

**6。查看各线程运行情况**

这个是重点，我们需要知道各线程的运行情况，特别是否被synchronized阻塞了。

![](/user_images/479-6.png)

注意右下角，有四个状态说明，分别是：

1.  运行(Running)：我们最喜欢的状态。说明该线程正在执行代码，没有问题。
2.  休眠(Sleeping)：调用了Thread.sleep后的状态，说明线程正停在某个Thread.sleep处
3.  等待(Wait)：手动调用了wait方法，或者某些IO操作，在阻塞中等待数据。
4.  监视(Monitor)：这里就是我想找的问题了。它表示线程想执行一段synchronized中的代码，但是发现已经有其它线程正在执行，自己被block了，只能无奈地等待。如果这种状态多，说明程序需要好好优化。

从上面的这个图可以看到，下面多个线程都处于"监视"状态。多个线程都卡在了独木桥的一头过不去，干不了活干着急呢。

当然这个程序是我专门设计成这样的，存在着严重的性能问题，需要好好优化。

**7。查看各线程的统计数据**

如果我们需要一些统计数据，比如某个线程总共运行了多少时间，"运行"状态有多久（或百分比），休眠、等待、监视有多久，则需要用到"表"这一页。

![](/user_images/479-7.png)

从中可以看到这个悲催的程序，几分所有的时间都用在了synchronized的阻塞上了。只有百分之零点几的时间在运行中，效率可真低啊。

还可以使用图表方式来看这些数据，得到更直观的体验：

![](/user_images/479-8.png)

**8。查看各方法的运行时间**

想不想程序中到底是哪些方法一直在运行？可使用"抽样器"功能：

![](/user_images/479-9.png)

我们需要先点击上面的"CPU"按钮，它才会开始统计，下面的数据会慢慢多起来。从上图可以看出，程序一直在运行SynIncer.inc()方法，它占用了所有方法执行总时间的99.8%。如果我们想提高程序性能，则需要重点优化它，让它运行得更快。

还想知道方法被调用的次数？使用"Profiler"页中的功能：

![](/user_images/479-10.png)

它与抽样器很像，但是最后多了一个"调用次数"。

**9。查看哪些对象占用了最多的内存**

当出现了内存不足的错误时，想不想知道到底是哪些对象把内存都占用了？这时需要使用"抽样器"的"内存"检测功能：

![](/user_images/479-11.png)

从表中可以看出当前最多的是哪些对象，它们有多少个，用了多少个字节。

**10。安装更多插件**

jvisualvm还在线提供了很多插件，提供了更多的功能。我们可以通过"工具"->"插件"，找到并安装它们。推荐全装，比如我就安装了全部（当前有16个）：

![](/user_images/479-12.png)

安装重启后，再找到某个程序节点，就会发现有更多的标签页可用。

**11。查看MBeans**

MBeans可以将程序中的某些信息暴露给外部。有一些库在设计时，就考虑到了这一点。如果我们不满足于前面那些基础信息，可以在这里看看。

![](/user_images/479-13.png)

由于当前程序没有使用到提供MBeans信息的库，所以看不到什么多少有用的信息。如果你使用了某些数据库连接池（提供了MBeans功能的），可以在这里看到池里的一些信息，还可以通过"Operations"标签页，对程序数据进行一些修改。

**12。查看gc情况**

垃圾回收是我们不能忽略的一个地方。我们可以通过"Visual GC"页，查看到非常详细的垃圾回收情况。

![](/user_images/479-14.png)

可以说，这个功能提供的信息真是非常地详尽，连两个小Eden的情况也实时地表现出来了。不过要看懂这些数据，还是需要先到网上看看讲解Java垃圾回收的文章，了解其内部原理才行。

**13。更多更详细的监测内容**

Tracer页提供了更多的监测内容

![](/user_images/479-15.png)

可以看到程序中遍布探针，让我们实时了解到各处的运行情况。先选中感兴趣的内容，然后点击"Start"按钮即可。

![](/user_images/479-16.png)

这一块比较专业，普通开发人员可能都不知道这些数据到底有什么用。但专业人士可能会觉得会很需要它们。

JvisualVM的大部分功能都已经演示完了，我想它的功能的确很强大，在我们平时的开发中会非常有用。
